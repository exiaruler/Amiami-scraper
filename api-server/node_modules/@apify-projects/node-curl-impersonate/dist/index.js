"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurlImpersonate = void 0;
const tslib_1 = require("tslib");
const proc = tslib_1.__importStar(require("child_process"));
const path = tslib_1.__importStar(require("path"));
const presets_js_1 = require("./presets.js");
const utils_js_1 = require("./utils.js");
class CurlImpersonate {
    _url;
    options;
    validMethods;
    binary;
    fullBinary;
    debugLogger;
    impersonatePresets;
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.validMethods = ['GET', 'POST'];
        this.debugLogger = options.debugLogger;
        this.binary = '';
        this.fullBinary = '';
        this.impersonatePresets = ['chrome-110', 'chrome-116', 'firefox-109', 'firefox-117'];
    }
    set url(urlString) {
        this._url = (0, utils_js_1.escapeUrl)(urlString);
    }
    get url() {
        return this._url;
    }
    checkIfPresetAndMerge() {
        if (this.options.impersonate === undefined)
            return;
        if (this.impersonatePresets.includes(this.options.impersonate)) {
            const preset = presets_js_1.presets[this.options.impersonate];
            // make sure that own headers override the preset headers, e.g. if we pass custom user-agent
            this.options.headers = {
                ...preset.headers,
                ...this.options.headers,
            };
            this.options.flags = this.options.flags ? this.options.flags.concat(preset.flags) : preset.flags;
        }
    }
    async makeRequest(url) {
        if (url !== undefined)
            this.url = url;
        return new Promise((resolve, reject) => {
            if (this.validateOptions(this.options)) {
                this.setProperBinary();
                this.checkIfPresetAndMerge();
                const headers = this.convertHeaderObjectToCURL();
                const flags = this.options.flags || [];
                if (this.options.method === 'GET') {
                    this.getRequest(flags, headers)
                        .then((response) => resolve(response))
                        .catch((error) => reject(error));
                }
                else if (this.options.method === 'POST') {
                    this.postRequest(flags, headers, this.options.body)
                        .then((response) => resolve(response))
                        .catch((error) => reject(error));
                }
                else {
                    // Handle other HTTP methods if needed
                    reject(new Error('Unsupported HTTP method'));
                }
            }
            else {
                reject(new Error('Invalid options'));
            }
        });
    }
    validateOptions(options) {
        if (this.validMethods.includes(options.method.toUpperCase())) {
            if (options.body !== undefined && options.method === 'GET') {
                throw new Error('Method is GET with an HTTP payload!');
            }
            else {
                const isValidUrl = URL.canParse(this.url);
                if (isValidUrl)
                    return true;
                throw new Error('URL is invalid! Must have http:// or https:// !');
            }
        }
        else {
            throw new Error(`Invalid Method! Valid HTTP methods are ${this.validMethods}`);
        }
    }
    setupBodyArgument(body) {
        if (body !== undefined) {
            try {
                return JSON.stringify(body);
            }
            catch {
                return body; // Assume that content type is anything except www-form-urlencoded or form-data, not quite sure if graphql is supported.
            }
        }
        else {
            throw new Error(`Body is undefined in a post request! Current body is ${this.options.body}`);
        }
    }
    setProperBinary() {
        const isFF = this.options.impersonate === 'firefox-109' || this.options.impersonate === 'firefox-117';
        switch (process.platform) {
            case 'linux':
                if (process.arch === 'x64') {
                    if (isFF) {
                        this.binary = 'curl-impersonate-firefox-linux-x86';
                    }
                    else {
                        this.binary = 'curl-impersonate-chrome-linux-x86';
                    }
                    break;
                }
                else if (process.arch === 'arm') {
                    if (isFF) {
                        this.binary = 'curl-impersonate-firefox-linux-aarch64';
                    }
                    else {
                        this.binary = 'curl-impersonate-chrome-linux-aarch64';
                    }
                    break;
                }
                else {
                    throw new Error(`Unsupported architecture: ${process.arch}`);
                }
            case 'darwin':
                if (process.arch === 'arm64') {
                    this.binary = 'curl-impersonate-chrome-darwin-arm64';
                }
                else if (isFF) {
                    this.binary = 'curl-impersonate-firefox-darwin-x86';
                }
                else {
                    this.binary = 'curl-impersonate-chrome-darwin-x86';
                }
                break;
            default:
                throw new Error(`Unsupported Platform! ${process.platform}`);
        }
    }
    async getRequest(flags, headers) {
        // GET REQUEST
        flags = flags.concat(['-v', '-L', '-w', '%{stderr}%{url_effective}']);
        const binpath = this.fullBinary || path.join(__dirname, '..', 'bin', this.binary);
        const args = `${flags.join(' ')} ${headers} '${this.url}'`;
        this.debugLogger(`Sending curl request: ${binpath} ${args}`);
        const result = await this.spawnAsync(`${binpath} ${args}`, {
            shell: true,
        });
        const response = result.stdout.toString();
        const verbose = result.stderr.toString();
        const requestData = this.extractRequestData(verbose);
        const respHeaders = this.extractResponseHeaders(verbose);
        const url = this.extractResponseUrl(verbose);
        const returnObject = {
            ipAddress: requestData.ipAddress,
            port: requestData.port,
            statusCode: requestData.statusCode,
            response,
            responseHeaders: respHeaders,
            requestHeaders: this.options.headers,
            verboseStatus: !!this.options.verbose,
            url,
        };
        return returnObject;
    }
    // Promise wrapper around basic spawn
    async spawnAsync(command, options) {
        const child = proc.spawn(command, options);
        let data = '';
        for await (const chunk of child.stdout) {
            data += chunk;
        }
        let error = '';
        for await (const chunk of child.stderr) {
            error += chunk;
        }
        const exitCode = await new Promise((resolve) => {
            child.on('close', resolve);
        });
        if (exitCode) {
            this.debugLogger(`subprocess error exit code: ${exitCode}, ${error}`);
            throw new Error(`Failed to send API request with exit code, retrying`);
        }
        return {
            stdout: data,
            stderr: error,
        };
    }
    async postRequest(flags, headers, body) {
        // POST REQUEST
        flags = flags.concat(['-v', '-L', '-w', '%{stderr}%{url_effective}']);
        const curlBody = this.setupBodyArgument(body);
        const binpath = this.fullBinary || path.join(__dirname, '..', 'bin', this.binary);
        const args = `${flags.join(' ')} ${headers} '${this.url}'`;
        const result = await this.spawnAsync(`${binpath} ${args} -d '${curlBody}'`, {
            shell: true,
        });
        const response = result.stdout.toString();
        const cleanedPayload = response.replace(/\s+\+\s+/g, '');
        const verbose = result.stderr.toString();
        const requestData = this.extractRequestData(verbose);
        const respHeaders = this.extractResponseHeaders(verbose);
        const url = this.extractResponseUrl(verbose);
        const returnObject = {
            ipAddress: requestData.ipAddress,
            port: requestData.port,
            statusCode: requestData.statusCode,
            response: cleanedPayload,
            responseHeaders: respHeaders,
            requestHeaders: this.options.headers,
            verboseStatus: this.options.verbose,
            url,
        };
        return returnObject;
    }
    extractRequestData(verbose) {
        // Define regular expressions to extract information
        const ipAddressRegex = /Trying (\S+):(\d+)/;
        const httpStatusRegex = /< HTTP\/2 (\d+) ([^\n]+)/;
        // Extract IP address and port
        const ipAddressMatch = verbose.match(ipAddressRegex);
        let port;
        let ipAddress;
        if (ipAddressMatch) {
            ipAddress = ipAddressMatch[1];
            port = parseInt(ipAddressMatch[2], 10);
        }
        // Extract HTTP status code and headers
        const httpStatusMatch = verbose.match(httpStatusRegex);
        let statusCode;
        if (httpStatusMatch) {
            statusCode = parseInt(httpStatusMatch[1], 10);
        }
        return {
            ipAddress,
            port,
            statusCode,
        };
    }
    extractResponseHeaders(verbose) {
        const httpResponseRegex = /< ([^\n]+)/g;
        const responseHeaders = {};
        const match = verbose.match(httpResponseRegex);
        if (match) {
            match.forEach((header) => {
                const headerWithoutPrefix = header.substring(2); // Remove the first two characters
                const headerParts = headerWithoutPrefix.split(': ');
                if (headerParts.length > 1) {
                    const headerName = headerParts[0].trim(); // Trim any leading/trailing spaces
                    const headerValue = headerParts[1].trim(); // Trim any leading/trailing spaces
                    responseHeaders[headerName] = headerValue;
                }
            });
        }
        return responseHeaders;
    }
    /**
     * Extracts the loaded URL from the verbose output.
     */
    extractResponseUrl = (verbose) => {
        const urlRegex = /^https?:\/\/.+$/m;
        return verbose.match(urlRegex)?.[0];
    };
    convertHeaderObjectToCURL() {
        return Object.entries(this.options.headers)
            .map(([key, value]) => `-H '${key}: ${value}'`)
            .join(' ');
    }
}
exports.CurlImpersonate = CurlImpersonate;
exports.default = CurlImpersonate;
//# sourceMappingURL=index.js.map